#!/usr/bin/env python3
"""
Macro Maker Pro v2.1 - Complete Edition
Advanced GUI automation tool with image recognition and enhanced OCR

Features:
- Point-and-click macro recording
- Image recognition with conditional branching
- Generalized OCR with multiple extraction modes
- Quick action sequences
- Enhanced keyboard shortcuts
- Backward compatibility with existing macros
"""

import tkinter as tk
from tkinter import simpledialog, messagebox, filedialog
import threading
import time
import re
import json
import sys
import os
import numpy as np

from pynput import mouse
import pyautogui
import pyperclip
import mss
from PIL import Image
import pytesseract

class MacroMaker:
    def __init__(self, master):
        self.master = master
        master.title("Macro Maker Pro v2.1 - Complete Edition")
        master.geometry("900x700")

        # Actions: ('click', x, y), ('drag', (x1,y1),(x2,y2)), ('delay', secs),
        #          ('copy',), ('paste',), ('hotkey', key1, key2, ...),
        #          ('ocr', (x1,y1,x2,y2), mode, pattern, processing),
        #          ('img_check', image_path, (x1,y1,x2,y2), sub_actions, threshold)
        self.actions = []
        self.loop_count = 1
        self.auto_delay = tk.BooleanVar(value=False)
        self.auto_delay_time = tk.DoubleVar(value=0.5)
        self.macro_running = False
        self.macro_thread = None
        self.current_file = None

        self._setup_ui()
        self._setup_shortcuts()

    def _setup_ui(self):
        """Initialize the user interface"""
        # Menu Bar
        self._create_menu()
        
        # Status Bar
        self._create_status_bar()
        
        # Recording Buttons
        self._create_recording_buttons()
        
        # Quick Actions Bar
        self._create_quick_actions()
        
        # Action Control Buttons
        self._create_control_buttons()
        
        # Execution Controls
        self._create_execution_controls()
        
        # Actions Listbox
        self._create_actions_list()

    def _create_menu(self):
        """Create the menu bar"""
        menubar = tk.Menu(self.master)
        self.master.config(menu=menubar)
        
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Macro (Ctrl+N)", command=self.new_macro)
        file_menu.add_command(label="Open Macro (Ctrl+O)", command=self.load_macro)
        file_menu.add_command(label="Save Macro (Ctrl+S)", command=self.save_macro)
        file_menu.add_command(label="Save As...", command=self.save_macro_as)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.master.quit)

    def _create_status_bar(self):
        """Create the status bar"""
        status_frame = tk.Frame(self.master)
        status_frame.pack(fill=tk.X, padx=5, pady=2)
        self.status_label = tk.Label(status_frame, text="Ready", relief=tk.SUNKEN, anchor=tk.W)
        self.status_label.pack(fill=tk.X)

    def _create_recording_buttons(self):
        """Create the main recording buttons"""
        record_frame = tk.Frame(self.master)
        record_frame.pack(pady=4)
        
        record_btns = [
            ("üñ±Ô∏è Click", self.record_click),
            ("‚ÜóÔ∏è Drag", self.record_drag),
            ("‚è±Ô∏è Delay", self.add_delay),
            ("üìã Copy", self.record_copy),
            ("üìÑ Paste", self.record_paste),
            ("üëÅÔ∏è OCR", self.record_ocr),
            ("üîç Img Check", self.record_img_check),
        ]
        
        for i, (text, cmd) in enumerate(record_btns):
            tk.Button(record_frame, text=text, command=cmd, width=10).grid(row=0, column=i, padx=2)

    def _create_quick_actions(self):
        """Create quick action buttons for common sequences"""
        quick_frame = tk.Frame(self.master)
        quick_frame.pack(pady=2)
        
        tk.Label(quick_frame, text="Quick Actions:", font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=5)
        
        quick_actions = [
            ("Click + Copy", self._quick_click_copy),
            ("Click + Paste", self._quick_click_paste),
            ("Drag + Copy", self._quick_drag_copy),
            ("Triple Click", self._quick_triple_click),
            ("Ctrl+A + Copy", self._quick_select_all_copy),
        ]
        
        for text, command in quick_actions:
            tk.Button(quick_frame, text=text, command=command, 
                     font=("Arial", 8), pady=1).pack(side=tk.LEFT, padx=1)

    def _create_control_buttons(self):
        """Create action control buttons"""
        control_frame = tk.Frame(self.master)
        control_frame.pack(pady=4)
        
        control_btns = [
            ("‚úèÔ∏è Edit", self.edit_action),
            ("üóëÔ∏è Delete", self.delete_action),
            ("üìã Duplicate", self.duplicate_action),
            ("‚¨ÜÔ∏è Move Up", self.move_up),
            ("‚¨áÔ∏è Move Down", self.move_down),
            ("üíæ Insert Delay", self.insert_delay),
        ]
        
        for i, (text, cmd) in enumerate(control_btns):
            tk.Button(control_frame, text=text, command=cmd, width=10).grid(row=0, column=i, padx=2)

    def _create_execution_controls(self):
        """Create execution control panel"""
        exec_frame = tk.Frame(self.master)
        exec_frame.pack(pady=4)
        
        tk.Label(exec_frame, text="Loops:").grid(row=0, column=0, padx=2)
        tk.Button(exec_frame, text="Set Count", command=self.set_loop, width=8).grid(row=0, column=1, padx=2)
        self.loop_label = tk.Label(exec_frame, text=f"{self.loop_count}", font=("Arial", 10, "bold"))
        self.loop_label.grid(row=0, column=2, padx=5)
        
        tk.Checkbutton(exec_frame, text="Auto Delay", variable=self.auto_delay).grid(row=0, column=3, padx=5)
        tk.Entry(exec_frame, textvariable=self.auto_delay_time, width=5).grid(row=0, column=4, padx=2)
        tk.Label(exec_frame, text="s").grid(row=0, column=5)
        
        self.start_btn = tk.Button(exec_frame, text="‚ñ∂Ô∏è Start (F5)", command=self.start_macro, 
                                  bg="#4CAF50", fg="white", font=("Arial", 10, "bold"), width=12)
        self.start_btn.grid(row=0, column=6, padx=5)
        
        self.stop_btn = tk.Button(exec_frame, text="‚èπÔ∏è Stop (Esc)", command=self.stop_macro, 
                                 bg="#f44336", fg="white", font=("Arial", 10, "bold"), width=12, state=tk.DISABLED)
        self.stop_btn.grid(row=0, column=7, padx=5)
        
        tk.Button(exec_frame, text="üîç Preview", command=self.preview_macro, width=8).grid(row=0, column=8, padx=2)
        tk.Button(exec_frame, text="üóëÔ∏è Clear All", command=self.clear_actions, width=8).grid(row=0, column=9, padx=2)

    def _create_actions_list(self):
        """Create the actions listbox with scrollbar"""
        list_frame = tk.Frame(self.master)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        scrollbar = tk.Scrollbar(list_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.listbox = tk.Listbox(list_frame, width=100, height=15, yscrollcommand=scrollbar.set,
                                 font=("Consolas", 10), selectmode=tk.SINGLE)
        self.listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.listbox.yview)

    def _setup_shortcuts(self):
        """Set up all keyboard shortcuts"""
        # Basic shortcuts
        self.master.bind('<Control-n>', lambda e: self.new_macro())
        self.master.bind('<Control-o>', lambda e: self.load_macro())
        self.master.bind('<Control-s>', lambda e: self.save_macro())
        self.master.bind('<Delete>', lambda e: self.delete_action())
        self.master.bind('<F5>', lambda e: self.start_macro())
        self.master.bind('<Escape>', lambda e: self.stop_macro())
        
        # Enhanced shortcuts
        self.master.bind('<Control-r>', lambda e: self.start_macro())
        self.master.bind('<Control-d>', lambda e: self.duplicate_action())
        self.master.bind('<Control-e>', lambda e: self.edit_action())
        self.master.bind('<Control-t>', lambda e: self._quick_click_copy())
        self.master.bind('<Control-y>', lambda e: self._quick_click_paste())
        
        # Update title to show shortcuts
        self.master.title("Macro Maker Pro v2.1 | Ctrl+R=Run | Ctrl+T=QuickCopy | Ctrl+Y=QuickPaste")

    # === CORE FUNCTIONALITY ===
    
    def update_status(self, message):
        """Update the status bar message"""
        self.status_label.config(text=message)

    def new_macro(self):
        """Create a new macro"""
        if self.actions and not messagebox.askyesno("New Macro", "Clear current macro?"):
            return
        self.actions = []
        self.listbox.delete(0, tk.END)
        self.current_file = None
        self.master.title("Macro Maker Pro v2.1")
        self.update_status("New macro created")

    def save_macro(self):
        """Save the current macro"""
        if self.current_file:
            self._save_to_file(self.current_file)
        else:
            self.save_macro_as()

    def save_macro_as(self):
        """Save macro with file dialog"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("Macro files", "*.json"), ("All files", "*.*")],
            title="Save Macro As"
        )
        if filename:
            self._save_to_file(filename)

    def _save_to_file(self, filename):
        """Save macro data to file"""
        try:
            macro_data = {
                "actions": self.actions,
                "loop_count": self.loop_count,
                "auto_delay": self.auto_delay.get(),
                "auto_delay_time": self.auto_delay_time.get()
            }
            with open(filename, 'w') as f:
                json.dump(macro_data, f, indent=2)
            
            self.current_file = filename
            self.master.title(f"Macro Maker Pro v2.1 - {filename}")
            self.update_status(f"Saved: {filename}")
            messagebox.showinfo("Save", f"Macro saved to {filename}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Failed to save macro:\n{e}")

    def load_macro(self):
        """Load macro from file"""
        if self.actions and not messagebox.askyesno("Load Macro", "Replace current macro?"):
            return
            
        filename = filedialog.askopenfilename(
            filetypes=[("Macro files", "*.json"), ("All files", "*.*")],
            title="Load Macro"
        )
        if filename:
            try:
                with open(filename, 'r') as f:
                    macro_data = json.load(f)
                
                self.actions = macro_data.get("actions", [])
                self.loop_count = macro_data.get("loop_count", 1)
                self.auto_delay.set(macro_data.get("auto_delay", False))
                self.auto_delay_time.set(macro_data.get("auto_delay_time", 0.5))
                
                # Refresh UI
                self.listbox.delete(0, tk.END)
                for action in self.actions:
                    self.listbox.insert(tk.END, self._format_action(action))
                
                self.loop_label.config(text=f"{self.loop_count}")
                self.current_file = filename
                self.master.title(f"Macro Maker Pro v2.1 - {filename}")
                self.update_status(f"Loaded: {filename}")
                messagebox.showinfo("Load", f"Macro loaded from {filename}")
            except Exception as e:
                messagebox.showerror("Load Error", f"Failed to load macro:\n{e}")

    def _format_action(self, action):
        """Format an action for display in the listbox"""
        typ = action[0]
        if typ == 'click':
            return f"üñ±Ô∏è Click at ({action[1]}, {action[2]})"
        elif typ == 'drag':
            return f"‚ÜóÔ∏è Drag from {action[1]} to {action[2]}"
        elif typ == 'delay':
            return f"‚è±Ô∏è Delay {action[1]:.2f}s"
        elif typ == 'copy':
            return "üìã Copy (Ctrl+C)"
        elif typ == 'paste':
            return "üìÑ Paste (Ctrl+V)"
        elif typ == 'hotkey':
            keys = ' + '.join(action[1:])
            return f"‚å®Ô∏è Hotkey: {keys}"
        elif typ == 'ocr':
            if len(action) >= 5:  # New format with options
                coords, mode, pattern, processing = action[1], action[2], action[3], action[4]
                mode_desc = {
                    'all_text': 'All text',
                    'numbers': 'Numbers only', 
                    'email': 'Email addresses',
                    'custom': f'Custom: {pattern}'
                }.get(mode, mode)
                return f"üëÅÔ∏è OCR ({mode_desc}) ‚Üí {processing}"
            else:  # Legacy format
                return f"üëÅÔ∏è OCR region: {action[1]} (legacy)"
        elif typ == 'img_check':
            image_path = os.path.basename(action[1]) if len(action) > 1 else "unknown"
            sub_count = len(action[3]) if len(action) > 3 else 0
            return f"üîç Image Check: {image_path} ({sub_count} sub-actions)"
        return str(action)

    def _maybe_auto_delay(self):
        """Add auto delay if enabled"""
        if self.auto_delay.get():
            d = self.auto_delay_time.get()
            self.actions.append(('delay', d))
            self.listbox.insert(tk.END, f"‚è±Ô∏è Delay {d:.2f}s (auto)")

    # === RECORDING METHODS ===

    def record_click(self):
        """Record a mouse click"""
        self.update_status("Click anywhere to record this click...")
        messagebox.showinfo("Record Click", "Click anywhere to record this click.")
        
        def on_click(x, y, button, pressed):
            if pressed:
                action = ('click', x, y)
                self.actions.append(action)
                # Schedule UI updates on the main thread
                self.master.after(0, lambda: (
                    self.listbox.insert(tk.END, self._format_action(action)),
                    self._maybe_auto_delay(),
                    self.update_status("Click recorded successfully")
                ))
                return False
        mouse.Listener(on_click=on_click).start()

    def record_drag(self):
        """Record a mouse drag"""
        self.update_status("Click and drag to record this action...")
        messagebox.showinfo("Record Drag", "Click and drag to record this action.")
        
        coords = []
        def on_click(x, y, button, pressed):
            if pressed:
                coords.clear()
                coords.append((x, y))
            else:
                coords.append((x, y))
                if len(coords) == 2:
                    action = ('drag', coords[0], coords[1])
                    self.actions.append(action)
                    # Schedule UI updates on the main thread
                    self.master.after(0, lambda: (
                        self.listbox.insert(tk.END, self._format_action(action)),
                        self._maybe_auto_delay(),
                        self.update_status("Drag recorded successfully")
                    ))
                    return False
        mouse.Listener(on_click=on_click).start()

    def record_copy(self):
        """Record a copy action"""
        action = ('copy',)
        self.actions.append(action)
        self.listbox.insert(tk.END, self._format_action(action))
        self._maybe_auto_delay()
        self.update_status("Copy action added")

    def record_paste(self):
        """Record a paste action"""
        action = ('paste',)
        self.actions.append(action) 
        self.listbox.insert(tk.END, self._format_action(action))
        self._maybe_auto_delay()
        self.update_status("Paste action added")

    def record_ocr(self):
        """Record an OCR action with enhanced options"""
        self.update_status("Click upper-left then lower-right to define OCR region...")
        messagebox.showinfo("Record OCR Region", "Click upper-left then release lower-right to define OCR region.")
        
        coords = []
        def on_click(x, y, button, pressed):
            if pressed:
                coords.clear()
                coords.append((x, y))
            else:
                coords.append((x, y))
                if len(coords) == 2:
                    # Schedule the dialog creation on the main thread
                    self.master.after(0, lambda: self._configure_ocr_options(coords))
                    return False
        mouse.Listener(on_click=on_click).start()

    def _configure_ocr_options(self, coords):
        """Configure OCR options through a dialog"""
        dialog = tk.Toplevel(self.master)
        dialog.title("OCR Configuration")
        dialog.geometry("500x400")
        dialog.transient(self.master)
        dialog.grab_set()
        
        # Variables for OCR options
        mode_var = tk.StringVar(value="all_text")
        pattern_var = tk.StringVar()
        processing_var = tk.StringVar(value="copy")
        
        tk.Label(dialog, text="OCR Configuration", font=("Arial", 14, "bold")).pack(pady=10)
        
        # OCR Mode Selection
        mode_frame = tk.LabelFrame(dialog, text="What to Extract", padx=10, pady=10)
        mode_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Radiobutton(mode_frame, text="All text (copy everything)", 
                      variable=mode_var, value="all_text").pack(anchor="w")
        tk.Radiobutton(mode_frame, text="Numbers only (any digits found)", 
                      variable=mode_var, value="numbers").pack(anchor="w")
        tk.Radiobutton(mode_frame, text="Email addresses", 
                      variable=mode_var, value="email").pack(anchor="w")
        tk.Radiobutton(mode_frame, text="Custom pattern (regex)", 
                      variable=mode_var, value="custom").pack(anchor="w")
        
        # Pattern Entry
        pattern_frame = tk.LabelFrame(dialog, text="Custom Pattern (if selected)", padx=10, pady=10)
        pattern_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Label(pattern_frame, text="Regex pattern:").pack(anchor="w")
        pattern_entry = tk.Entry(pattern_frame, textvariable=pattern_var, width=50)
        pattern_entry.pack(fill="x", pady=2)
        
        tk.Label(pattern_frame, text="Examples: \\d{4,8} (4-8 digits), \\b\\w+@\\w+\\.\\w+\\b (emails)", 
                font=("Arial", 8), fg="gray").pack(anchor="w")
        
        # Processing Options
        process_frame = tk.LabelFrame(dialog, text="What to do with extracted text", padx=10, pady=10)
        process_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Radiobutton(process_frame, text="Copy to clipboard", 
                      variable=processing_var, value="copy").pack(anchor="w")
        tk.Radiobutton(process_frame, text="Save to variable (show in status)", 
                      variable=processing_var, value="show").pack(anchor="w")
        tk.Radiobutton(process_frame, text="Copy first match only", 
                      variable=processing_var, value="first").pack(anchor="w")
        tk.Radiobutton(process_frame, text="Copy all matches (separated by spaces)", 
                      variable=processing_var, value="all").pack(anchor="w")
        
        # Buttons
        button_frame = tk.Frame(dialog)
        button_frame.pack(pady=20)
        
        def save_ocr():
            mode = mode_var.get()
            pattern = pattern_var.get() if mode == "custom" else ""
            processing = processing_var.get()
            
            if mode == "custom" and not pattern:
                messagebox.showwarning("Missing Pattern", "Please enter a regex pattern for custom mode.")
                return
            
            (x1, y1), (x2, y2) = coords
            action = ('ocr', (x1, y1, x2, y2), mode, pattern, processing)
            self.actions.append(action)
            self.listbox.insert(tk.END, self._format_action(action))
            self._maybe_auto_delay()
            self.update_status(f"OCR region added: {mode} mode")
            dialog.destroy()
        
        def cancel_ocr():
            self.update_status("OCR recording cancelled")
            dialog.destroy()
        
        tk.Button(button_frame, text="Add OCR Action", command=save_ocr, 
                 bg="#4CAF50", fg="white", font=("Arial", 10, "bold")).pack(side="left", padx=5)
        tk.Button(button_frame, text="Cancel", command=cancel_ocr).pack(side="left", padx=5)

    def record_img_check(self):
        """Record an image check action with branching logic"""
        # First, let user select reference image
        image_path = filedialog.askopenfilename(
            filetypes=[("Image files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All files", "*.*")],
            title="Select Reference Image"
        )
        if not image_path:
            self.update_status("Image check cancelled")
            return
            
        self.update_status("Click and drag to define search region...")
        messagebox.showinfo("Define Search Region", 
                          "Click and drag to define the region where the image should be found.")
        
        coords = []
        def on_click(x, y, button, pressed):
            if pressed:
                coords.clear()
                coords.append((x, y))
            else:
                coords.append((x, y))
                if len(coords) == 2:
                    # Schedule the dialog creation on the main thread
                    self.master.after(0, lambda: self._finish_img_check_recording(coords, image_path))
                    return False
        mouse.Listener(on_click=on_click).start()

    def _finish_img_check_recording(self, coords, image_path):
        """Complete the image check recording process"""
        (x1, y1), (x2, y2) = coords
        
        # Get similarity threshold from user
        threshold = simpledialog.askfloat(
            "Image Similarity", 
            "Enter similarity threshold (0.0-1.0, higher = more strict):",
            initialvalue=0.8,
            minvalue=0.0,
            maxvalue=1.0
        )
        if threshold is None:
            threshold = 0.8
        
        # Create dialog for sub-actions
        sub_actions = self._create_sub_actions_dialog()
        
        action = ('img_check', image_path, (x1, y1, x2, y2), sub_actions, threshold)
        self.actions.append(action)
        self.listbox.insert(tk.END, self._format_action(action))
        self._maybe_auto_delay()
        
        img_name = os.path.basename(image_path)
        self.update_status(f"Image check added: {img_name} with {len(sub_actions)} sub-actions")

    def _create_sub_actions_dialog(self):
        """Create a dialog to define sub-actions for image check branching"""
        sub_actions = []
        
        # Create a simple dialog window
        dialog = tk.Toplevel(self.master)
        dialog.title("Define Sub-Actions")
        dialog.geometry("600x400")
        dialog.transient(self.master)
        dialog.grab_set()
        
        tk.Label(dialog, text="Define actions to execute when image IS found:", 
                font=("Arial", 12, "bold")).pack(pady=10)
        
        # Listbox for sub-actions
        frame = tk.Frame(dialog)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        sub_listbox = tk.Listbox(frame)
        sub_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        scrollbar = tk.Scrollbar(frame, orient=tk.VERTICAL, command=sub_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        sub_listbox.config(yscrollcommand=scrollbar.set)
        
        # Button frame for adding actions
        btn_frame = tk.Frame(dialog)
        btn_frame.pack(fill=tk.X, padx=10, pady=5)
        
        def add_click():
            messagebox.showinfo("Record Click", "Click anywhere to record this click for sub-actions.")
            dialog.withdraw()  # Hide dialog temporarily
            
            def on_click(x, y, button, pressed):
                if pressed:
                    action = ('click', x, y)
                    sub_actions.append(action)
                    # Schedule UI updates on the main thread
                    self.master.after(0, lambda: (
                        sub_listbox.insert(tk.END, self._format_action(action)),
                        dialog.deiconify()
                    ))
                    return False
            mouse.Listener(on_click=on_click).start()
        
        def add_delay():
            d = simpledialog.askfloat("Delay", "Enter delay in seconds:", initialvalue=1.0)
            if d is not None:
                action = ('delay', d)
                sub_actions.append(action)
                sub_listbox.insert(tk.END, self._format_action(action))
        
        def add_copy():
            action = ('copy',)
            sub_actions.append(action)
            sub_listbox.insert(tk.END, self._format_action(action))
        
        def add_paste():
            action = ('paste',)
            sub_actions.append(action)
            sub_listbox.insert(tk.END, self._format_action(action))
        
        def remove_action():
            selection = sub_listbox.curselection()
            if selection:
                idx = selection[0]
                sub_actions.pop(idx)
                sub_listbox.delete(idx)
        
        # Action buttons
        tk.Button(btn_frame, text="Add Click", command=add_click).pack(side=tk.LEFT, padx=2)
        tk.Button(btn_frame, text="Add Delay", command=add_delay).pack(side=tk.LEFT, padx=2)
        tk.Button(btn_frame, text="Add Copy", command=add_copy).pack(side=tk.LEFT, padx=2)
        tk.Button(btn_frame, text="Add Paste", command=add_paste).pack(side=tk.LEFT, padx=2)
        tk.Button(btn_frame, text="Remove", command=remove_action).pack(side=tk.LEFT, padx=2)
        
        # Done button
        def done():
            dialog.destroy()
        
        tk.Button(dialog, text="Done", command=done, font=("Arial", 12, "bold")).pack(pady=10)
        
        # Wait for dialog to be closed
        dialog.wait_window()
        
        return sub_actions

    # === QUICK ACTIONS ===

    def _quick_click_copy(self):
        """Add click followed by copy action"""
        self.update_status("Click where you want to click then copy...")
        messagebox.showinfo("Quick Click+Copy", "Click anywhere to record click + copy sequence.")
        
        def on_click(x, y, button, pressed):
            if pressed:
                # Add click action
                click_action = ('click', x, y)
                self.actions.append(click_action)
                
                # Add copy action
                copy_action = ('copy',)
                self.actions.append(copy_action)
                
                # Schedule UI updates on the main thread
                self.master.after(0, lambda: (
                    self.listbox.insert(tk.END, self._format_action(click_action)),
                    self.listbox.insert(tk.END, self._format_action(copy_action)),
                    self.update_status("Click + Copy sequence added")
                ))
                return False
        mouse.Listener(on_click=on_click).start()

    def _quick_click_paste(self):
        """Add click followed by paste action"""
        self.update_status("Click where you want to click then paste...")
        messagebox.showinfo("Quick Click+Paste", "Click anywhere to record click + paste sequence.")
        
        def on_click(x, y, button, pressed):
            if pressed:
                # Add click action
                click_action = ('click', x, y)
                self.actions.append(click_action)
                
                # Add paste action
                paste_action = ('paste',)
                self.actions.append(paste_action)
                
                # Schedule UI updates on the main thread
                self.master.after(0, lambda: (
                    self.listbox.insert(tk.END, self._format_action(click_action)),
                    self.listbox.insert(tk.END, self._format_action(paste_action)),
                    self.update_status("Click + Paste sequence added")
                ))
                return False
        mouse.Listener(on_click=on_click).start()

    def _quick_drag_copy(self):
        """Add drag followed by copy action"""
        self.update_status("Drag to select text then auto-copy...")
        messagebox.showinfo("Quick Drag+Copy", "Drag to select text, will auto-add copy action.")
        
        coords = []
        def on_click(x, y, button, pressed):
            if pressed:
                coords.clear()
                coords.append((x, y))
            else:
                coords.append((x, y))
                if len(coords) == 2:
                    # Add drag action
                    drag_action = ('drag', coords[0], coords[1])
                    self.actions.append(drag_action)
                    
                    # Add copy action
                    copy_action = ('copy',)
                    self.actions.append(copy_action)
                    
                    # Schedule UI updates on the main thread
                    self.master.after(0, lambda: (
                        self.listbox.insert(tk.END, self._format_action(drag_action)),
                        self.listbox.insert(tk.END, self._format_action(copy_action)),
                        self.update_status("Drag + Copy sequence added")
                    ))
                    return False
        mouse.Listener(on_click=on_click).start()

    def _quick_triple_click(self):
        """Add triple click (select line) action"""
        self.update_status("Click where you want to triple-click...")
        messagebox.showinfo("Triple Click", "Click anywhere to add triple-click action.")
        
        def on_click(x, y, button, pressed):
            if pressed:
                actions_to_add = []
                # Add three quick clicks
                for i in range(3):
                    click_action = ('click', x, y)
                    self.actions.append(click_action)
                    actions_to_add.append((click_action, f" ({i+1}/3)"))
                    
                    # Add tiny delay between clicks
                    if i < 2:
                        delay_action = ('delay', 0.05)
                        self.actions.append(delay_action)
                        actions_to_add.append((delay_action, ""))
                
                # Schedule UI updates on the main thread
                def update_ui():
                    for action, suffix in actions_to_add:
                        self.listbox.insert(tk.END, self._format_action(action) + suffix)
                    self.update_status("Triple-click sequence added")
                
                self.master.after(0, update_ui)
                return False
        mouse.Listener(on_click=on_click).start()

    def _quick_select_all_copy(self):
        """Add Ctrl+A + Copy sequence"""
        # Add Ctrl+A (select all)
        select_action = ('hotkey', 'ctrl', 'a')
        self.actions.append(select_action)
        self.listbox.insert(tk.END, self._format_action(select_action))
        
        # Add copy
        copy_action = ('copy',)
        self.actions.append(copy_action)
        self.listbox.insert(tk.END, self._format_action(copy_action))
        
        self.update_status("Select All + Copy sequence added")

    # === ACTION MANAGEMENT ===

    def add_delay(self):
        """Add a delay action"""
        d = simpledialog.askfloat("Delay (s)", "Enter delay in seconds:", minvalue=0.0, initialvalue=1.0)
        if d is not None: 
            action = ('delay', d)
            self.actions.append(action)
            self.listbox.insert(tk.END, self._format_action(action))
            self.update_status(f"Added {d:.2f}s delay")

    def insert_delay(self):
        """Insert delay after selected action"""
        sel = self.listbox.curselection()
        if not sel: 
            messagebox.showwarning("No Selection", "Select an action first.")
            return
        d = simpledialog.askfloat("Insert Delay", "Enter delay in seconds:", minvalue=0.0, initialvalue=1.0)
        if d is not None: 
            idx = sel[0] + 1  # Insert after selected item
            action = ('delay', d)
            self.actions.insert(idx, action)
            self.listbox.insert(idx, self._format_action(action))
            self.update_status(f"Inserted {d:.2f}s delay")

    def duplicate_action(self):
        """Duplicate the selected action"""
        sel = self.listbox.curselection()
        if not sel:
            messagebox.showwarning("No Selection", "Select an action to duplicate.")
            return
        
        idx = sel[0]
        action = self.actions[idx].copy() if hasattr(self.actions[idx], 'copy') else tuple(self.actions[idx])
        self.actions.insert(idx + 1, action)
        self.listbox.insert(idx + 1, self._format_action(action) + " (copy)")
        self.listbox.select_clear(0, tk.END)
        self.listbox.select_set(idx + 1)
        self.update_status("Action duplicated")

    def delete_action(self):
        """Delete the selected action"""
        sel = self.listbox.curselection()
        if not sel:
            messagebox.showwarning("No Selection", "Select an action to delete.")
            return
        
        idx = sel[0]
        self.actions.pop(idx)
        self.listbox.delete(idx)
        self.update_status("Action deleted")

    def move_up(self):
        """Move selected action up"""
        sel = self.listbox.curselection()
        if not sel or sel[0] == 0:
            return
        
        idx = sel[0]
        self.actions[idx-1], self.actions[idx] = self.actions[idx], self.actions[idx-1]
        
        self.listbox.delete(idx-1, idx)
        self.listbox.insert(idx-1, self._format_action(self.actions[idx-1]))
        self.listbox.insert(idx, self._format_action(self.actions[idx]))
        self.listbox.select_set(idx-1)
        self.update_status("Action moved up")

    def move_down(self):
        """Move selected action down"""
        sel = self.listbox.curselection()
        if not sel or sel[0] >= len(self.actions) - 1:
            return
        
        idx = sel[0]
        self.actions[idx], self.actions[idx+1] = self.actions[idx+1], self.actions[idx]
        
        self.listbox.delete(idx, idx+1)
        self.listbox.insert(idx, self._format_action(self.actions[idx]))
        self.listbox.insert(idx+1, self._format_action(self.actions[idx+1]))
        self.listbox.select_set(idx+1)
        self.update_status("Action moved down")

    def edit_action(self):
        """Edit the selected action"""
        sel = self.listbox.curselection()
        if not sel:
            messagebox.showwarning("No Selection", "Select an action to edit.")
            return
        
        idx = sel[0]
        act = self.actions[idx]
        typ = act[0]
        
        if typ == 'delay':
            new_delay = simpledialog.askfloat("Edit Delay", "Enter new delay:", initialvalue=act[1])
            if new_delay is not None:
                self.actions[idx] = ('delay', new_delay)
                self.listbox.delete(idx)
                self.listbox.insert(idx, self._format_action(self.actions[idx]))
                self.listbox.select_set(idx)
                self.update_status("Delay action edited")
        else:
            messagebox.showinfo("Edit", f"Editing {typ} actions is not yet supported.")

    def preview_macro(self):
        """Show a preview of what the macro will do"""
        if not self.actions:
            messagebox.showwarning("Empty", "No actions to preview.")
            return
        
        preview_text = f"Macro Preview - Will execute {self.loop_count} time(s):\n\n"
        for i, action in enumerate(self.actions, 1):
            preview_text += f"{i:2d}. {self._format_action(action)}\n"
        
        preview_window = tk.Toplevel(self.master)
        preview_window.title("Macro Preview")
        preview_window.geometry("600x400")
        
        text_widget = tk.Text(preview_window, wrap=tk.WORD, font=("Consolas", 10))
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, preview_text)
        text_widget.config(state=tk.DISABLED)

    def clear_actions(self):
        """Clear all actions"""
        if self.actions and messagebox.askyesno("Clear All", "Clear all actions?"):
            self.actions = []
            self.listbox.delete(0, tk.END)
            self.update_status("All actions cleared")

    def set_loop(self):
        """Set loop count"""
        count = simpledialog.askinteger("Loop Count", "Enter number of loops:", 
                                       minvalue=1, initialvalue=self.loop_count)
        if count:
            self.loop_count = count
            self.loop_label.config(text=f"{self.loop_count}")
            self.update_status(f"Loop count set to {self.loop_count}")

    # === IMAGE PROCESSING ===

    def _compare_images(self, reference_path, screenshot_region, threshold=0.8):
        """Compare reference image with screenshot region using template matching"""
        try:
            # Load reference image
            if not os.path.exists(reference_path):
                print(f"Reference image not found: {reference_path}")
                return False
                
            ref_img = Image.open(reference_path)
            ref_array = np.array(ref_img)
            
            # Convert screenshot region to numpy array
            screen_array = np.array(screenshot_region)
            
            # Convert to grayscale for template matching
            if len(ref_array.shape) == 3:
                ref_gray = np.dot(ref_array[...,:3], [0.299, 0.587, 0.114])
            else:
                ref_gray = ref_array
                
            if len(screen_array.shape) == 3:
                screen_gray = np.dot(screen_array[...,:3], [0.299, 0.587, 0.114])
            else:
                screen_gray = screen_array
            
            # Simple correlation-based matching
            if ref_gray.shape[0] > screen_gray.shape[0] or ref_gray.shape[1] > screen_gray.shape[1]:
                return False
            
            # Calculate normalized cross-correlation
            try:
                from scipy import ndimage
                # Use scipy if available for better matching
                correlation = ndimage.correlate(screen_gray, ref_gray, mode='constant')
                max_correlation = correlation.max()
                
                # Normalize correlation value
                ref_sum = (ref_gray ** 2).sum()
                screen_sum = (screen_gray ** 2).sum()
                
                if ref_sum == 0 or screen_sum == 0:
                    return False
                    
                normalized_correlation = max_correlation / (ref_sum * screen_sum) ** 0.5
                
            except ImportError:
                # Fallback to simple pixel-by-pixel comparison
                if ref_gray.shape != screen_gray.shape:
                    # Resize reference to match screen region
                    ref_img_resized = ref_img.resize(screen_array.shape[1::-1])
                    ref_array_resized = np.array(ref_img_resized)
                    if len(ref_array_resized.shape) == 3:
                        ref_gray = np.dot(ref_array_resized[...,:3], [0.299, 0.587, 0.114])
                    else:
                        ref_gray = ref_array_resized
                
                # Simple pixel difference calculation
                diff = np.abs(ref_gray - screen_gray)
                similarity = 1.0 - (diff.mean() / 255.0)
                normalized_correlation = similarity
            
            print(f"Image similarity: {normalized_correlation:.3f}, threshold: {threshold}")
            return normalized_correlation >= threshold
            
        except Exception as e:
            print(f"Error comparing images: {e}")
            return False

    def _process_ocr_text(self, text, mode, pattern):
        """Process OCR text based on mode and return results"""
        if not text:
            return None
            
        if mode == "all_text":
            return text.strip()
            
        elif mode == "numbers":
            # Find all sequences of digits
            numbers = re.findall(r'\d+', text)
            return numbers if numbers else None
            
        elif mode == "email":
            # Find email addresses
            email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
            emails = re.findall(email_pattern, text)
            return emails if emails else None
            
        elif mode == "custom":
            # Use custom regex pattern
            if not pattern:
                return None
            try:
                matches = re.findall(pattern, text)
                return matches if matches else None
            except re.error as e:
                print(f"Invalid regex pattern '{pattern}': {e}")
                return None
                
        elif mode == "legacy":
            # Legacy behavior - look for 6-9 digit numbers and pad
            found_number = None
            
            # First try to find 9-digit number
            m9 = re.search(r'\b(\d{9})\b', text)
            if m9:
                found_number = m9.group(1)
                print(f"Found 9-digit number: {found_number}")
            else:
                # Try to find 8-digit number and pad with 1 zero
                m8 = re.search(r'\b(\d{8})\b', text)
                if m8:
                    found_number = "0" + m8.group(1)
                    print(f"Found 8-digit number: {m8.group(1)} -> padded to: {found_number}")
                else:
                    # Try to find 7-digit number and pad with 2 zeros
                    m7 = re.search(r'\b(\d{7})\b', text)
                    if m7:
                        found_number = "00" + m7.group(1)
                        print(f"Found 7-digit number: {m7.group(1)} -> padded to: {found_number}")
                    else:
                        # Try to find 6-digit number and pad with 3 zeros
                        m6 = re.search(r'\b(\d{6})\b', text)
                        if m6:
                            found_number = "000" + m6.group(1)
                            print(f"Found 6-digit number: {m6.group(1)} -> padded to: {found_number}")
            
            return found_number
            
        return None

    # === MACRO EXECUTION ===

    def start_macro(self):
        """Start macro execution"""
        if not self.actions:
            messagebox.showwarning("Empty Macro", "No actions to execute.")
            return
            
        if self.macro_running:
            messagebox.showwarning("Already Running", "Macro is already running.")
            return
        
        self.macro_running = True
        self.start_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        
        self.macro_thread = threading.Thread(target=self.run_macro)
        self.macro_thread.daemon = True
        self.macro_thread.start()

    def stop_macro(self):
        """Stop macro execution"""
        self.macro_running = False
        self.start_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)
        self.update_status("Macro stopped")

    def run_macro(self):
        """Execute the macro actions"""
        try:
            # Initial delay to let user prepare
            for i in range(3, 0, -1):
                if not self.macro_running:
                    return
                self.master.after(0, lambda cnt=i: self.update_status(f"Starting in {cnt}..."))
                time.sleep(1)
            
            total_actions = len(self.actions) * self.loop_count
            action_count = 0
            
            for loop in range(self.loop_count):
                if not self.macro_running:
                    break
                    
                self.master.after(0, lambda l=loop+1: self.update_status(f"Executing loop {l}/{self.loop_count}"))
                
                for i, act in enumerate(self.actions):
                    if not self.macro_running:
                        break
                        
                    action_count += 1
                    progress = f"Action {action_count}/{total_actions}"
                    self.master.after(0, lambda p=progress: self.update_status(p))
                    
                    typ = act[0]
                    try:
                        if typ == 'click': 
                            _, x, y = act
                            pyautogui.click(x, y)
                            
                        elif typ == 'drag': 
                            _, (x1, y1), (x2, y2) = act
                            pyautogui.mouseDown(x1, y1)
                            pyautogui.moveTo(x2, y2, duration=0.1)
                            pyautogui.mouseUp()
                            
                        elif typ == 'delay': 
                            delay_time = act[1]
                            # Break delay into smaller chunks to allow stopping
                            steps = max(1, int(delay_time * 10))  # 0.1s chunks
                            for _ in range(steps):
                                if not self.macro_running:
                                    break
                                time.sleep(delay_time / steps)
                                
                        elif typ == 'copy': 
                            pyautogui.hotkey('ctrl', 'c')
                            
                        elif typ == 'paste': 
                            pyautogui.hotkey('ctrl', 'v')
                            
                        elif typ == 'hotkey':
                            # Execute custom hotkey combination
                            keys = act[1:]
                            pyautogui.hotkey(*keys)
                            
                        elif typ == 'ocr':
                            # Handle both legacy and new OCR formats
                            if len(act) >= 5:  # New format
                                x1, y1, x2, y2 = act[1]
                                mode, pattern, processing = act[2], act[3], act[4]
                            else:  # Legacy format - convert to new format
                                x1, y1, x2, y2 = act[1]
                                mode, pattern, processing = "legacy", "", "copy"
                            
                            left, top = min(x1, x2), min(y1, y2)
                            width, height = abs(x2 - x1), abs(y2 - y1)
                            
                            with mss.mss() as sct:
                                monitor = {'top': top, 'left': left, 'width': width, 'height': height}
                                sct_img = sct.grab(monitor)
                                img = Image.frombytes('RGB', sct_img.size, sct_img.rgb)
                            
                            # Enhanced OCR with multiple configurations
                            configs = ['--psm 6', '--psm 7', '--psm 8', '--psm 13']
                            text = ""
                            
                            for config in configs:
                                try:
                                    text = pytesseract.image_to_string(img, config=config).strip()
                                    if text:  # If we got some text, use it
                                        break
                                except:
                                    continue
                            
                            if not text:
                                text = pytesseract.image_to_string(img).strip()  # Fallback
                            
                            print(f"OCR extracted text: '{text}'")  # Debug output
                            
                            # Process based on mode
                            result = self._process_ocr_text(text, mode, pattern)
                            
                            if result:
                                # Handle processing option
                                if processing in ['copy', 'first']:
                                    if isinstance(result, list):
                                        pyperclip.copy(result[0] if result else "")
                                        self.master.after(0, lambda r=result[0]: self.update_status(f"OCR: Copied '{r}'"))
                                    else:
                                        pyperclip.copy(str(result))
                                        self.master.after(0, lambda r=result: self.update_status(f"OCR: Copied '{r}'"))
                                elif processing == 'all':
                                    if isinstance(result, list):
                                        combined = " ".join(str(r) for r in result)
                                        pyperclip.copy(combined)
                                        self.master.after(0, lambda r=combined: self.update_status(f"OCR: Copied {len(result)} matches"))
                                    else:
                                        pyperclip.copy(str(result))
                                        self.master.after(0, lambda r=result: self.update_status(f"OCR: Copied '{r}'"))
                                elif processing == 'show':
                                    display_result = result if isinstance(result, str) else str(result)
                                    self.master.after(0, lambda r=display_result: self.update_status(f"OCR Result: '{r}'"))
                            else:
                                self.master.after(0, lambda: self.update_status(f"OCR: No matches found for {mode} mode"))
                                
                        elif typ == 'img_check':
                            # Image check with branching logic
                            image_path, (x1, y1, x2, y2), sub_actions, threshold = act[1], act[2], act[3], act[4]
                            left, top = min(x1, x2), min(y1, y2)
                            width, height = abs(x2 - x1), abs(y2 - y1)
                            
                            # Take screenshot of the region
                            with mss.mss() as sct:
                                monitor = {'top': top, 'left': left, 'width': width, 'height': height}
                                sct_img = sct.grab(monitor)
                                img = Image.frombytes('RGB', sct_img.size, sct_img.rgb)
                            
                            # Compare with reference image
                            image_found = self._compare_images(image_path, img, threshold)
                            
                            img_name = os.path.basename(image_path)
                            if image_found:
                                # Execute sub-actions when image is found
                                self.master.after(0, lambda n=img_name: self.update_status(f"Image found: {n} - executing sub-actions"))
                                print(f"Image found: {img_name} - executing {len(sub_actions)} sub-actions")
                                
                                # Execute each sub-action
                                for sub_act in sub_actions:
                                    if not self.macro_running:
                                        break
                                        
                                    sub_typ = sub_act[0]
                                    try:
                                        if sub_typ == 'click':
                                            _, sx, sy = sub_act
                                            pyautogui.click(sx, sy)
                                        elif sub_typ == 'drag':
                                            _, (sx1, sy1), (sx2, sy2) = sub_act
                                            pyautogui.mouseDown(sx1, sy1)
                                            pyautogui.moveTo(sx2, sy2, duration=0.1)
                                            pyautogui.mouseUp()
                                        elif sub_typ == 'delay':
                                            delay_time = sub_act[1]
                                            steps = max(1, int(delay_time * 10))
                                            for _ in range(steps):
                                                if not self.macro_running:
                                                    break
                                                time.sleep(delay_time / steps)
                                        elif sub_typ == 'copy':
                                            pyautogui.hotkey('ctrl', 'c')
                                        elif sub_typ == 'paste':
                                            pyautogui.hotkey('ctrl', 'v')
                                    except Exception as sub_e:
                                        print(f"Error executing sub-action {sub_typ}: {sub_e}")
                            else:
                                # Image not found - continue with main flow
                                self.master.after(0, lambda n=img_name: self.update_status(f"Image not found: {n} - continuing main flow"))
                                print(f"Image not found: {img_name} - continuing with main macro")
                                
                    except Exception as e:
                        error_msg = f"Error executing {typ} action: {str(e)}"
                        print(error_msg)
                        self.master.after(0, lambda msg=error_msg: messagebox.showerror("Execution Error", msg))
                        
            # Macro completed
            if self.macro_running:
                self.master.after(0, lambda: self.update_status("Macro completed successfully!"))
                self.master.after(0, lambda: messagebox.showinfo("Complete", "Macro execution finished!"))
            
        except Exception as e:
            error_msg = f"Fatal error during macro execution: {str(e)}"
            print(error_msg)
            self.master.after(0, lambda msg=error_msg: messagebox.showerror("Fatal Error", msg))
            
        finally:
            # Reset UI state
            self.macro_running = False
            self.master.after(0, lambda: self.start_btn.config(state=tk.NORMAL))
            self.master.after(0, lambda: self.stop_btn.config(state=tk.DISABLED))
            if not self.macro_running:
                self.master.after(0, lambda: self.update_status("Ready"))

if __name__ == "__main__":
    root = tk.Tk()
    app = MacroMaker(root)
    root.mainloop()
